<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <title>Procession</title>
  <!-- <link href='http://fonts.googleapis.com/css?family=Parisienne|Oxygen+Mono|PT+Mono|Offside|Nova+Mono|Averia+Serif+Libre|Alex+Brush|Autour+One|Share+Tech+Mono|Merriweather|Maven+Pro|Raleway' rel='stylesheet' type='text/css'>-->
  <!-- todo: why doesn't fork me float?-->
  <link href="https://fonts.googleapis.com/css?family=Cutive+Mono|Sorts+Mill+Goudy|Mate|Oxygen+Mono|Offside|Raleway:400,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy">
  <link rel="stylesheet" type="text/css" href="css/ascetic.css">
  <link rel="stylesheet" type="text/css" href="css/style.css">
</html>
<body><a href="https://github.com/bigeasy/procession/"><img style="position: fixed; top: 0; left: 0; border: 0" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
  <div class="container">
    <div class="unit welcome">
      <h1>Procession</h1>
      <!-- todo: code font is too small for body text font-->
    </div>
    <div class="unit description markdown include" data-file="index.md"><p>Procession is an evented work queue or stream. I use it to create efficent
evented pipelines of events in my applications. It is a simple alternative to
Node.js streams for events when back pressure is not needed.</p>
<p>With Procession you can broadcast an event zero, one or more waiting listeners.
Listeners listen for events by creating a consumer on the procession and
listening for the consumer&apos;s <code>shift</code> function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> procession = <span class="hljs-keyword">new</span> Procession

<span class="hljs-keyword">var</span> consumer = procession.consumer()

consumer.shift(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error
    <span class="hljs-built_in">console</span>.log(value)
})

procession.push(<span class="hljs-number">1</span>)
</code></pre>
<p>You can chain processions together using <code>pipe</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> first = <span class="hljs-keyword">new</span> Procession
<span class="hljs-keyword">var</span> second = <span class="hljs-keyword">new</span> Procession

<span class="hljs-keyword">var</span> consumer = second.consumer()
first.consumer().pipe(second)

consumer.shift(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, value</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error
    <span class="hljs-built_in">console</span>.log(value)
})

procession.push(<span class="hljs-number">1</span>)
</code></pre>
<p>This is useful if want to build a series of transforms. Each transform an have
an input and output procession.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> compressor = <span class="hljs-keyword">new</span> Compressor
<span class="hljs-keyword">var</span> encryptor = <span class="hljs-keyword">new</span> Encryptor

compressor.output.pipe(encryptor.input)

compressor.push({ <span class="hljs-attr">secret</span>: <span class="hljs-number">5</span> })
</code></pre>
<p>When you push onto a <code>Procession</code> that has no consumers it is essentially a
no-op, so it is not expensive to keep a procession around that has optional
events that you can optionally listen to.</p>
<p>You can have multiple consumers that listen</p>
<p><strong>TODO</strong>: Implement back pressure by passing an optional callback to <code>push</code>.</p>
<p>Unlike <a href="https://github.com/bigeasy/turnstile">Turnstile</a> events in Procession
are enqueued and then forgotten. There is no mechanism by which to send a
response to a response bound to a particular message through the procession. In
this sense they are like Node.js streams.</p>
<h2 id="notes">Notes</h2>
<p>How do you quickly create filters?</p>
<pre><code class="lang-javascript">procession.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
    <span class="hljs-keyword">return</span> message.type != <span class="hljs-string">&apos;administrative&apos;</span>)
}).pump(nextProcession)

<span class="hljs-comment">// This could replace `join`.</span>
procession.filter(myFilter, <span class="hljs-number">1</span>).shift(<span class="hljs-keyword">async</span>())
</code></pre>
<p>Currently, I&apos;m using a singly-linked list so that advancing the final consumer
or iterator will make the now unreferenced final entry eligible for garbage
collection, but as I consider wanting to implement back pressure, there appears
to be no good way to signal that an entry is no longer in use so that it&apos;s heft
could be removed from the weight of the procession. Reference counting is
difficult because it makes destroying a consumer difficult. Now destroying a
consumer requires that the consumer run through the linked list and decrement
the count. There is, however, no good reason to keep a doubly-linked list, even
though a reference count would make it possible to know when to unlink.</p>
<p>Some of things that I do with Turnstile could be done with this pipeline class.</p>
<p>Not sure why I&apos;d ever forgo visibility.</p>
<p>Took a lot of notes on how to maintain ordering but lost them with an overwrite.</p>
<ul>
<li>Add integer that wraps for ordering, so max total length is 0xffffffff.</li>
<li>When we shift, we check that the node is greater than least, do nothing.</li>
<li>When we shift, if node is equal to least we check that this is the last
consumer that is referencing it, if not, do nothing, otherwise, mark it is
deleted, notify listeners that it is outgoing.</li>
<li>Now we can have listeners that listen for incoming and outgoing nodes. With
these we can introduce counts, heft and a red-black tree for searching.</li>
<li>When we shift, we mark the nodes as shifted. If the user is holding onto a
shifted node and attempts to promote it to a consumer, we will abend.</li>
</ul>
</div>
  </div>
  <!-- todo: move into an edify plugin-->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-20388260-3', 'bigeasy.github.io');
    ga('send', 'pageview');
  </script>
</body>
<!-- vim: set ts=2 sw=2 nowrap:-->
